name: 'Generic Test Runner with JUnit'
description: 'Run any test command and convert output to JUnit format'
inputs:
  test-name:
    description: 'Name of the test suite'
    required: true
  setup-commands:
    description: 'Commands to run for setup (newline separated)'
    required: false
    default: ''
  test-command:
    description: 'The test command to run'
    required: true
  output-parser:
    description: 'Type of output parser (pytest-json, shellcheck-xml, generic)'
    required: false
    default: 'generic'
  continue-on-error:
    description: 'Whether to continue on test failure'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Setup environment
      shell: bash
      if: ${{ inputs.setup-commands != '' }}
      run: |
        mkdir -p test-results
        ${{ inputs.setup-commands }}

    - name: Run tests
      shell: bash
      run: |
        mkdir -p test-results
        set +e  # Don't exit on command failure
        if [[ "${{ inputs.output-parser }}" == "pytest-json" ]]; then
          ${{ inputs.test-command }} --json-report --json-report-file=test-results/${{ inputs.test-name }}-report.json
          exit_code=$?
        elif [[ "${{ inputs.output-parser }}" == "shellcheck-xml" ]]; then
          ${{ inputs.test-command }} > test-results/${{ inputs.test-name }}-output.txt 2>&1
          exit_code=$?
        else
          ${{ inputs.test-command }} > test-results/${{ inputs.test-name }}-output.txt 2>&1
          exit_code=$?
        fi
        echo "TEST_EXIT_CODE=$exit_code" >> $GITHUB_ENV
        if [[ "${{ inputs.continue-on-error }}" == "false" && $exit_code -ne 0 ]]; then
          exit $exit_code
        fi
        # Always create a minimal JUnit XML if the main test output is missing
        junit_file="test-results/${{ inputs.test-name }}-junit.xml"
        if [[ ! -f "$junit_file" ]]; then
          echo '<testsuites><testsuite name="${{ inputs.test-name }}" tests="1" failures="1" errors="1"><testcase classname="${{ inputs.test-name }}" name="${{ inputs.test-name }}-error"><failure message="No test results or test runner failed to produce output"/></testcase></testsuite></testsuites>' > "$junit_file"
        fi

    - name: Setup environment
      shell: bash
      if: ${{ inputs.setup-commands != '' }}
      run: |
        mkdir -p test-results
        ${{ inputs.setup-commands }}

    - name: Run tests
      shell: bash
      run: |
        mkdir -p test-results
        set +e  # Don't exit on command failure
        if [[ "${{ inputs.output-parser }}" == "pytest-json" ]]; then
          ${{ inputs.test-command }} --json-report --json-report-file=test-results/${{ inputs.test-name }}-report.json
          exit_code=$?
        elif [[ "${{ inputs.output-parser }}" == "shellcheck-xml" ]]; then
          ${{ inputs.test-command }} > test-results/${{ inputs.test-name }}-output.txt 2>&1
          exit_code=$?
        else
          ${{ inputs.test-command }} > test-results/${{ inputs.test-name }}-output.txt 2>&1
          exit_code=$?
        fi
        echo "TEST_EXIT_CODE=$exit_code" >> $GITHUB_ENV
        if [[ "${{ inputs.continue-on-error }}" == "false" && $exit_code -ne 0 ]]; then
          exit $exit_code
        fi
        # Always create a minimal JUnit XML if the main test output is missing
        junit_file="test-results/${{ inputs.test-name }}-junit.xml"
        if [[ ! -f "$junit_file" ]]; then
          echo '<testsuites><testsuite name="${{ inputs.test-name }}" tests="1" failures="1" errors="1"><testcase classname="${{ inputs.test-name }}" name="${{ inputs.test-name }}-error"><failure message="No test results or test runner failed to produce output"/></testcase></testsuite></testsuites>' > "$junit_file"
        fi
        
    - name: Convert to JUnit XML
      shell: bash
      run: |
        python3 -u -c "
        import json
        import xml.etree.ElementTree as ET
        from xml.dom import minidom
        import os
        import sys
        import traceback

        test_name = '${{ inputs.test-name }}'
        parser_type = '${{ inputs.output-parser }}'
        exit_code = int(os.environ.get('TEST_EXIT_CODE', '0'))

        testsuites = ET.Element('testsuites')
        testsuite = ET.SubElement(testsuites, 'testsuite')
        testsuite.set('name', test_name)

        def write_failure(message):
            testsuite.set('tests', '1')
            testsuite.set('failures', '1')
            testsuite.set('errors', '0')
            testcase = ET.SubElement(testsuite, 'testcase')
            testcase.set('classname', test_name)
            testcase.set('name', f'{test_name}-error')
            failure = ET.SubElement(testcase, 'failure')
            failure.set('message', message)

        try:
            if parser_type == 'pytest-json':
                try:
                    with open(f'test-results/{test_name}-report.json', 'r') as f:
                        data = json.load(f)
                    testsuite.set('tests', str(data.get('summary', {}).get('total', 0)))
                    testsuite.set('failures', str(data.get('summary', {}).get('failed', 0)))
                    testsuite.set('errors', '0')
                    for test in data.get('tests', []):
                        testcase = ET.SubElement(testsuite, 'testcase')
                        testcase.set('classname', test.get('nodeid', '').split('::')[0] if '::' in test.get('nodeid', '') else test_name)
                        testcase.set('name', test.get('nodeid', 'unknown'))
                        if test.get('outcome') == 'failed':
                            failure = ET.SubElement(testcase, 'failure')
                            failure.set('message', test.get('call', {}).get('longrepr', 'Test failed'))
                    # If no tests found, add a dummy failure if exit_code != 0
                    if int(testsuite.get('tests', '0')) == 0 and exit_code != 0:
                        write_failure(f'{test_name} failed to run or no tests collected (exit code {exit_code})')
                except Exception as e:
                    tb = traceback.format_exc()
                    write_failure(f'Could not generate report: {str(e)}\\n{tb}\\n(exit code {exit_code})')
            else:
                # Generic parser - treat as single test
                testsuite.set('tests', '1')
                testsuite.set('failures', '1' if exit_code != 0 else '0')
                testsuite.set('errors', '0')
                testcase = ET.SubElement(testsuite, 'testcase')
                testcase.set('classname', test_name)
                testcase.set('name', f'{test_name}-check')
                if exit_code != 0:
                    failure = ET.SubElement(testcase, 'failure')
                    try:
                        with open(f'test-results/{test_name}-output.txt', 'r') as f:
                            output = f.read()
                        failure.set('message', output[:1000])  # Limit message length
                    except FileNotFoundError:
                        failure.set('message', f'{test_name} failed with exit code {exit_code}')
        except Exception as e:
            tb = traceback.format_exc()
            # Last-resort: always write a file
            try:
                write_failure(f'Unexpected error in JUnit conversion: {str(e)}\\n{tb}')
            except Exception as inner:
                # If even this fails, write a minimal XML file
                with open(f'test-results/{test_name}-junit.xml', 'w') as f:
                    f.write(f'<testsuites><testsuite name=\"{test_name}\" tests=\"1\" failures=\"1\" errors=\"1\"><testcase classname=\"{test_name}\" name=\"{test_name}-error\"><failure message=\"JUnit conversion failed: {str(inner)}\"/></testcase></testsuite></testsuites>')
                sys.exit(0)

        xml_str = minidom.parseString(ET.tostring(testsuites)).toprettyxml(indent='  ')
        with open(f'test-results/{test_name}-junit.xml', 'w') as f:
            f.write(xml_str)
        "
        
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: ${{ inputs.test-name }}-test-results
        path: test-results/${{ inputs.test-name }}-junit.xml
